# ==============================================================
# SERVER CONFIGURATION
# ==============================================================
server.port=8080
server.shutdown=graceful
# Timeout for incoming requests to prevent hanging connections
server.servlet.session.timeout=10m

# ==============================================================
# APPLICATION METADATA
# ==============================================================
spring.application.name=safaricom-booking-orchestrator
spring.main.banner-mode=off

# ==============================================================
# LOGGING (Best Practices: JSON format in Prod, Console in Dev)
# ==============================================================
# Root level: INFO (Standard). WARN for libraries to reduce noise.
logging.level.root=INFO
logging.level.org.springframework.web=INFO
logging.level.org.hibernate=WARN
logging.level.com.safaricom=DEBUG

# Log Pattern: clear timestamp and thread info
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
# File logging (optional - good for persistence)
logging.file.name=logs/app.log

# ==============================================================
# KAFKA CONFIGURATION (Messaging Glue)
# ==============================================================
spring.kafka.bootstrap-servers=${KAFKA_BROKER:localhost:9092}
spring.kafka.consumer.group-id=safaricom-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# ==============================================================
# DATASOURCE 1: BOOKING SERVICE (PostgreSQL)
# ==============================================================
# Note: We use custom prefixes (.booking) to match the Java Config
spring.datasource.booking.jdbc-url=jdbc:postgresql://${DB_HOST:localhost}:5432/booking_db
spring.datasource.booking.username=${BOOKING_DB_USER:safaricom}
spring.datasource.booking.password=${BOOKING_DB_PASS:password}
spring.datasource.booking.driver-class-name=org.postgresql.Driver

# Connection Pool Settings (HikariCP)
spring.datasource.booking.hikari.maximum-pool-size=10
spring.datasource.booking.hikari.minimum-idle=2
spring.datasource.booking.hikari.pool-name=BookingHikariPool

# ==============================================================
# DATASOURCE 2: AUDIT SERVICE (MySQL)
# ==============================================================
spring.datasource.audit.jdbc-url=jdbc:mysql://${DB_HOST:localhost}:3306/audit_db?allowPublicKeyRetrieval=true&useSSL=false
spring.datasource.audit.username=${AUDIT_DB_USER:root}
spring.datasource.audit.password=${AUDIT_DB_PASS:password}
spring.datasource.audit.driver-class-name=com.mysql.cj.jdbc.Driver

spring.datasource.audit.hikari.maximum-pool-size=5
spring.datasource.audit.hikari.pool-name=AuditHikariPool

# ==============================================================
# JPA / HIBERNATE SHARED SETTINGS
# ==============================================================
# Vital: Prevent LazyInitializationException by closing sessions after transaction
spring.jpa.open-in-view=false

# DDL Auto: 'validate' in production, 'update' in dev.
# Since we have multiple DBs, we control this in the Java Config classes, 
# but these defaults act as fallback.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false

# ==============================================================
# TESTING / LOCAL DEV (H2)
# ==============================================================
# Enable H2 console only for local debugging
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
# If using H2 as a fallback or for tests:
# spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1